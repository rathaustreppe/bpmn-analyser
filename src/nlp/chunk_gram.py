

class ChunkGram:
    """
    A class containing all pre-defined chunks.
    In later development this is put into a separate file,
    generated by a GUI-Tool.
    """
    # put ChunkGrams here
    pass



   # when defining multiple chunk-grammars, make sure
    # they have no space before them - and are correctly
    # aligned with tabulator
    # grammar = r"""
    # NN_VB_NN:       {<NN.?>+<VB.?><TO>?<DT>?<NN.?>+}
    # VB_NN_TO_NN:    {<VB.?>+<NN.?><TO>?<NN.?>+}
    # # """
    # #
    # parser = nltk.RegexpParser(grammar)
    # for sentence in sentences:
    #     parsed = parser.parse(sentence)
    #     pass
    #     for chunk in parsed:
    #         if isinstance(chunk, nltk.tree.Tree):
    #             if chunk.label() == 'VB_NN_TO_NN':
    #                 #chunk.draw()
    #                 extract_vb_nn_to_nn(chunk)
    #
    #             if chunk.label() == 'NN_VB_NN':
    #                 extract_nn_vb_nn(chunk)


    #def extract_nn_vb_nn(chunk: nltk.tree.Tree, sample_word: str):
    # verb = chunk.leaves()[0]
    # wordtype = get_wordnet_pos(verb[1])
    #
    # word = verb[0]
    # word = wordnet.synsets(word, wordtype)[0]
    # vb_lemmas = set([lemma.name() for lemma in word.lemmas()])
    #
    # word_lemmas = list()
    # for synset in wordnet.synsets(sample_word, wordtype):
    #     for lemma in synset.lemmas():
    #         word_lemmas.append(lemma.name())
    # word_lemmas = set(word_lemmas)
    #
    # intersection_synonyms = word_lemmas.intersection(vb_lemmas)
    # print(f'Chunk-Verb in Text: {vb_lemmas}')
    # print(f'LÃ¶sungs-Synonyme: {word_lemmas}')
    # print(f'union synonyms: {intersection_synonyms}')
    # if len(intersection_synonyms) > 0:
    #     print(f'ACCEPTED: {word}')
    # else:
    #     print(f'REJECTED: {word}')
    #
